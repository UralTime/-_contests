#include <stdio.h>
#include <string.h>

int z_max(char s[], int n) { // максимум z-функции
    int maxim = 0;
    int z[2001] = {0};  // массив длины n, i-ый элемент которого равен наибольшему числу символов, начиная с позиции i, совпадающих с префиксом строки s.
    for (int i = 1, l = 0, r = 0; i < n; i++) { // [l;r] - самый правый отрезок совпадения с префиксом
        if (i <= r) // текущая позиция лежит внутри отрезка совпадения
            z[i] = (r - i + 1 < z[i - l]) ? (r - i + 1) : z[i - l];
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) // пытаемся увеличить значение z[i] настолько, насколько это возможно (ручками проверяем дальше символы)
            z[i]++;
        if (i + z[i] - 1 > r) { // обновление текущего самого правого отрезка совпадения [l;r], если, конечно, это обновление требуется
            l = i;
            r = i + z[i] - 1;
        }
        if (z[i] > maxim) // max из массива
            maxim = z[i];
    }
    return maxim;
}

int main(void) {
    char s[2001];
    scanf("%2000s", s);
    int n = strlen(s), ans = 1; // пустая строка считается
    for (int i = 0; i < n; i++) {
        char cursreverse[i + 2]; // t = перевёрнутая (для z-функции) строка s[0:i]+s[i]
        cursreverse[0] = s[i];
        for (int j = 1; j <= i; j++) {
            cursreverse[j] = s[i - j];
        }
        cursreverse[i + 1] = '\0';
        // кол-во добавившихся различных подстрок, заканчивающихся на текущий символ это все (текущая длина строки) кроме макс.длины уже встречающегося префикса (меньшие тоже встретятся)
        ans += i + 1 - z_max(cursreverse, i + 1);
    }
    printf("%d", ans);
    return 0;
}